<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Are you kidding?</title>
    <link>https://nimisolo.github.io/index.xml</link>
    <description>Recent content on Are you kidding?</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 19 Feb 2017 08:42:58 +0800</lastBuildDate>
    <atom:link href="https://nimisolo.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Linux内核idle进程分析</title>
      <link>https://nimisolo.github.io/post/mwait_idle/</link>
      <pubDate>Sun, 19 Feb 2017 08:42:58 +0800</pubDate>
      
      <guid>https://nimisolo.github.io/post/mwait_idle/</guid>
      <description>

&lt;h3 id=&#34;写作背景&#34;&gt;写作背景&lt;/h3&gt;

&lt;p&gt;在当前KVM实现中，当vcpu中执行HLT指令时会发生VMexit，KVM模块中会进入&lt;code&gt;kvm_vcpu_block&lt;/code&gt;函数，从前此函数会快速将vcpu线程schedule out，但在配置了halt_poll_ns的情况下，当条件满足时会适当的busy loop一段时间，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void kvm_vcpu_block(struct kvm_vcpu *vcpu)
{
	...
		do {
			/*
			 * This sets KVM_REQ_UNHALT if an interrupt
			 * arrives.
			 */
			if (kvm_vcpu_check_block(vcpu) &amp;lt; 0) {
				++vcpu-&amp;gt;stat.halt_successful_poll;
				if (!vcpu_valid_wakeup(vcpu))
					++vcpu-&amp;gt;stat.halt_poll_invalid;
				goto out;
			}
			cur = ktime_get();
		} while (single_task_running() &amp;amp;&amp;amp; ktime_before(cur, stop));	
	...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当vcpu此时不再是halt状态 或 当前pcpu上不止一个可运行task 或 busy loop时间到期 这三者任一满足时将退出busy loop，在busy loop过程中CPU使用率肯定会冲高到100%。可是我们不想将这段时间被TOP工具即pmcint工具（利用PMU）统计到，前者可以通过修改内核cputime.c中的几个统计代码来实现，但是后者的话稍微有点麻烦。pmcint工具利用了PMU硬件打点的原理，我们没法修改统计，最后想到的办法是改造此busy loop，在其中进入C1 state，这样的话PMU计数器会暂停，从而使得pmcint暂停打点，这样既确保了vcpu性能，又无法使用户看到很高的占用率。&lt;/p&gt;

&lt;p&gt;细想一下，此处busy loop的好处是啥？无非就是在条件满足的情况下不要将vcpu线程切换出去，否则来回切换势必使得vcpu线程被唤醒不够及时，导致虚拟机性能受影响。这样来说的话，我们在busy loop中调用HLT/MWAIT也能起到一样的效果：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果使用MWAIT，我们可以用MONITOR监控让busy loop结束的变量，这样当需要结束时MWAIT会被breaken，从而与此前流程一样。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果使用HLT，则我们需要根据stop设置一个backend hrtimer，保证我们肯定能够从HLT中出来。（但是，这个方式肯定不如上述代码的实现，因为HLT的breaken事件中不包括内存监控，它没法及时监控到nr_running的变化，这可能会导致调度不及时）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cpu-cstates&#34;&gt;CPU Cstates&lt;/h3&gt;

&lt;p&gt;Cstates是ACPI规范中引入的，具体的可以看acpi spec，下面内容摘自&lt;a href=&#34;http://www.expreview.com/25426.html&#34;&gt;Haswell芯光大道之六：C-States十种状态解析&lt;/a&gt;
&lt;img src=&#34;static/intel-power-state.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;monitor-mwait指令&#34;&gt;MONITOR/MWAIT指令&lt;/h3&gt;

&lt;h4 id=&#34;会不会有安全问题&#34;&gt;会不会有安全问题&lt;/h4&gt;

&lt;p&gt;&lt;font color=red&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/font&gt;虚拟化下，如果guest kernel中执行了MONITOR gva指令，此时会不会影响到host中正处于mwait状态的cpu？例如：无论是某个vcpu STORE了该gva、或者某个pcpu STORE了某hva（而此hva的数值与该gva相等），都将引起mwait BROKEN?&lt;/p&gt;

&lt;p&gt;&lt;font color=blue&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;intel SDM vol3 26.3.3 / 27.5.6 说，VMentry/VMexit时会将可能有影响的所有“address-range monitoring”清除。（题外话：什么叫“可能有影响”？&lt;strong&gt;[a]&lt;/strong&gt;我觉得都是“可能有影响的”，因为该address-range是个virtual address，对于64位host+64位guest的线性地址空间大小是一样的，硬件上无法区分，所以应该是都会清除。&lt;strong&gt;[b]&lt;/strong&gt;但是这样的话又不对了，假如pcpu监控了hva1，然后它进入了guest，这时需要将hva1清除，当VMexit后并没有提到恢复对hva1的监控，那么此pcpu上后续STORE hva1不就不能被监控了吗？&lt;strong&gt;[c]&lt;/strong&gt;除非有种可能，address-range由至少二元组确定，即virtual address + cpu mode，但是这样的话SDM何不直接描述为“guest或non-root的address-range清除”即可？&lt;font color=red&gt;哎&amp;hellip;暂时不懂&lt;/font&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;intel SDM vol3 25.1.3 说，如果VM-execution control的“MONITOR exiting”为1，则MONITOR指令会导致VMexit。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在KVM中，在&lt;code&gt;setup_vmcs_config&lt;/code&gt;中“MONITOR exiting”是会强制为1的，所以vcpu只要执行该指令就会引起VMexit，退出处理&lt;code&gt;handle_monitor&lt;/code&gt;中直接跳过该指令、把它当做NOP来处理。&lt;/p&gt;

&lt;h3 id=&#34;linux-idle进程&#34;&gt;Linux idle进程&lt;/h3&gt;

&lt;h4 id=&#34;执行框架分析&#34;&gt;执行框架分析&lt;/h4&gt;

&lt;h4 id=&#34;intel-idle分析&#34;&gt;intel_idle分析&lt;/h4&gt;
</description>
    </item>
    
    <item>
      <title>ARM host/guest使用哪种timer</title>
      <link>https://nimisolo.github.io/post/arm-host/guest%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8Dtimer/</link>
      <pubDate>Sun, 05 Feb 2017 16:45:06 +0800</pubDate>
      
      <guid>https://nimisolo.github.io/post/arm-host/guest%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8Dtimer/</guid>
      <description>&lt;p&gt;ARM Generic Timer支持好几种timer，此前听说ARM linux host使用pyhsical timer，而guest使用virtual timer。&lt;font color=red&gt;一直不清楚ARM linux中是怎么探测和设置它的，今晚看了下有所眉目了。&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;首先来看个全局变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static enum ppi_nr arch_timer_uses_ppi = VIRT_PPI;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;arch_timer_uses_ppi&lt;/code&gt;表示使用的timer类型，默认是virtual timer。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;arch_timer_init&lt;/code&gt;中根据情况会对此作出调整：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	if (is_hyp_mode_available() || !arch_timer_ppi[VIRT_PPI]) {
		bool has_ppi;

		if (is_kernel_in_hyp_mode()) {
			arch_timer_uses_ppi = HYP_PPI;
			has_ppi = !!arch_timer_ppi[HYP_PPI];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，对于host来说，会调整成physical timer。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;__arch_timer_setup&lt;/code&gt;中会对所使用的clocksource做设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;		switch (arch_timer_uses_ppi) {
		case VIRT_PPI:
			clk-&amp;gt;set_state_shutdown = arch_timer_shutdown_virt;
			clk-&amp;gt;set_state_oneshot_stopped = arch_timer_shutdown_virt;
			clk-&amp;gt;set_next_event = arch_timer_set_next_event_virt;
			break;
		case PHYS_SECURE_PPI:
		case PHYS_NONSECURE_PPI:
		case HYP_PPI:
			clk-&amp;gt;set_state_shutdown = arch_timer_shutdown_phys;
			clk-&amp;gt;set_state_oneshot_stopped = arch_timer_shutdown_phys;
			clk-&amp;gt;set_next_event = arch_timer_set_next_event_phys;
			break;
		default:
			BUG();
		}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对不同的timer（physical或virtual），设置了不同的钩子处理函数。这样一来，以后对clock进行操作的时候就各走各的路了，从而区分开来了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>关于periodic-mode timer的问题</title>
      <link>https://nimisolo.github.io/post/%E5%85%B3%E4%BA%8Eperiodic-mode/</link>
      <pubDate>Sun, 05 Feb 2017 15:54:39 +0800</pubDate>
      
      <guid>https://nimisolo.github.io/post/%E5%85%B3%E4%BA%8Eperiodic-mode/</guid>
      <description>&lt;p&gt;今天和晓建讨论一个方案时，他说“即使定时器是periodic mode，当加入hrtimer时也有可能会去设置硬件计数器（tmict/tsc_deadline）的值”。
咦？！和我以前的认识不一样啊，根据以前的掌握：periodic mode情况下新加hrtimer时不会设置硬件计数器了，及时设置计数器是oneshot mode的做法啊！
于是重新翻了下相关代码，证明&lt;strong&gt;&lt;font color=red&gt;晓建理解错了、我的观点是正确的&lt;/font&gt;&lt;/strong&gt;。请看下面分析。&lt;/p&gt;

&lt;p&gt;我们以新加一个定时器的操作入手：&lt;code&gt;hrtimer_start --&amp;gt; hrtimer_start_range_ns
&lt;/code&gt;，在后者中有这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	leftmost = enqueue_hrtimer(timer, new_base);
	if (!leftmost)
		goto unlock;

	if (!hrtimer_is_hres_active(timer)) {
		/*
		 * Kick to reschedule the next tick to handle the new timer
		 * on dynticks target.
		 */
		if (new_base-&amp;gt;cpu_base-&amp;gt;nohz_active)
			wake_up_nohz_cpu(new_base-&amp;gt;cpu_base-&amp;gt;cpu);
	} else {
		hrtimer_reprogram(timer, new_base);
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;enqueue_hrtimer&lt;/code&gt;将（新添加的）hrtimer插入到当前的timerqueue（其实是一个rb-tree）中。如果该hrtimer是“将会最早到期”的，则它会放在rb-tree的最左端，即leftrmost为1；否则leftmost为0。&lt;/li&gt;
&lt;li&gt;如果不是最左端，则直接返回。这是因为：此函数是perdioc mode和oneshot mode公用的，如果此定时器将最早到期，oneshot mode会根据起到期时间重设硬件计数器。&lt;/li&gt;
&lt;li&gt;如果没有启动高精度定时器（&lt;code&gt;hrtimer_is_hres_active&lt;/code&gt;返回false），则不会重设硬件计数器；否则（oneshot mode）就通过&lt;code&gt;hrtimer_reprogram&lt;/code&gt;重设。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在需要弄清楚的就是：&lt;code&gt;hrtimer_is_hres_active&lt;/code&gt;什么情况下返回true。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static inline int hrtimer_is_hres_active(struct hrtimer *timer)
{
	return timer-&amp;gt;base-&amp;gt;cpu_base-&amp;gt;hres_active;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上就是看&lt;code&gt;hres_active&lt;/code&gt;是否为1。因此下面搜索下，看什么情况下会设置它为1。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static void hrtimer_switch_to_hres(void)
{
	struct hrtimer_cpu_base *base = this_cpu_ptr(&amp;amp;hrtimer_bases);

	if (tick_init_highres()) {
		printk(KERN_WARNING &amp;quot;Could not switch to high resolution &amp;quot;
				    &amp;quot;mode on CPU %d\n&amp;quot;, base-&amp;gt;cpu);
		return;
	}
	base-&amp;gt;hres_active = 1;
	......
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当&lt;code&gt;tick_init_highres&lt;/code&gt;返回false是，才会设置&lt;code&gt;hres_active&lt;/code&gt;为1。看名字，该函数的作用是初始化高精度定时器（即oneshot mode），深入该函数，可以发现：如果成功切换成oneshot，则会返回0。
好，到这里其实我们已经弄清楚了：
&lt;font color=red&gt;
+ 高精度highres其实是指onshot-mode。
+ periodic mode下，即使新加一个leftmost的hrtimer也不会重设硬件计数器。只有onshot mode下才会。
&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更进一步&lt;/strong&gt;，当hrtimer到期之后，是如何被处理的？
&lt;strong&gt;对于periodic-mode模式：&lt;/strong&gt;&lt;code&gt;tick_handle_periodic --&amp;gt; tick_periodic --&amp;gt; update_process_times --&amp;gt; run_local_timers --&amp;gt; hrtimer_run_queues --&amp;gt; __hrtimer_run_queues&lt;/code&gt;
&lt;strong&gt;对于oneshot-mode模式：&lt;/strong&gt;&lt;code&gt;hrtimer_interrupt --&amp;gt; __hrtimer_run_queues&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;处理超时的hrtimer是最终都是在&lt;strong&gt;&lt;code&gt;__hrtimer_run_queues&lt;/code&gt;&lt;/strong&gt;函数中完成，&lt;font color=red&gt;它会（根据当前时间）遍历所有已经超时的hrtimer，然后处理它们&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;再进一步&lt;/strong&gt;，为啥periodic-mode精度比oneshot-mode低低低？？
+ 因为periodic-mode下时钟中断触发时间是周期性的，也就是说在一个周期内到期的hrtimer只有在周期结束（时钟终端触发）时才能获得处理，显然实时性较差；并且如果一个周期内很多hrtimer到期，则依次处理它们，那么排在靠后的hrtimer实际上延迟就更大了。
+ oneshot-mode能够精确的根据leftmost hrtimer的到期时间来精确设置计数器，这样更加实时；并且根据此原理，一般多个hrtimer同时到期的情况应该比periodic-mode的少，则“依次处理”不会太长，这一点也比periodic-mode情况要好。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>